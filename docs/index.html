<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Atomics.waitAsync</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Atomics.waitAsync","titleHTML":"Atomics.waitAsync","number":"","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync"},{"type":"op","aoid":"HostResolveInAgent","refId":"sec-hostresolveinagent","location":"","referencingIds":[],"key":"HostResolveInAgent"},{"type":"clause","id":"sec-hostresolveinagent","aoid":"HostResolveInAgent","title":"HostResolveInAgent ( agentSignifier, promiseCapability, resolution)","titleHTML":"HostResolveInAgent ( <var>agentSignifier</var>, <var>promiseCapability</var>, <var>resolution</var>)","number":"1.1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_51"],"key":"HostResolveInAgent ( agentSignifier, promiseCapability, resolution)"},{"type":"term","term":"Waiter Record","refId":"sec-getwaiterlist","referencingIds":["_ref_2","_ref_3","_ref_8","_ref_9","_ref_24","_ref_30","_ref_33","_ref_36","_ref_41","_ref_49","_ref_69"],"id":"waiter-record","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"Waiter Record"},{"type":"table","id":"table-waiterrecord","node":{},"number":1,"caption":"Table 1: Waiter Record Fields","referencingIds":["_ref_0"],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"Table 1: Waiter Record Fields"},{"type":"term","term":"WaiterList","refId":"sec-getwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"WaiterList"},{"type":"term","term":"WaiterList Record","refId":"sec-getwaiterlist","referencingIds":["_ref_4"],"id":"waiterlist-record","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"WaiterList Record"},{"type":"table","id":"table-waiterlist","node":{},"number":2,"caption":"Table 2: WaiterList Record Fields","referencingIds":["_ref_1"],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"Table 2: WaiterList Record Fields"},{"type":"clause","id":"sec-getwaiterlist","aoid":null,"title":"GetWaiterList ( block, i )","titleHTML":"GetWaiterList ( <var>block</var>, <var>i</var> )","number":"1.2","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_5","_ref_6","_ref_7","_ref_10","_ref_11","_ref_12","_ref_13","_ref_14","_ref_15","_ref_16","_ref_19","_ref_20","_ref_22","_ref_23","_ref_29","_ref_31","_ref_32","_ref_35","_ref_37","_ref_38","_ref_39","_ref_44","_ref_48","_ref_50","_ref_58","_ref_81"],"key":"GetWaiterList ( block, i )"},{"type":"op","aoid":"EnterCriticalSection","refId":"sec-entercriticalsection","location":"","referencingIds":[],"key":"EnterCriticalSection"},{"type":"clause","id":"sec-entercriticalsection","aoid":"EnterCriticalSection","title":"EnterCriticalSection ( WL )","titleHTML":"EnterCriticalSection ( <var>WL</var> )","number":"1.3","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_25","_ref_46","_ref_60","_ref_82"],"key":"EnterCriticalSection ( WL )"},{"type":"op","aoid":"LeaveCriticalSection","refId":"sec-leavecriticalsection","location":"","referencingIds":[],"key":"LeaveCriticalSection"},{"type":"clause","id":"sec-leavecriticalsection","aoid":"LeaveCriticalSection","title":"LeaveCriticalSection ( WL )","titleHTML":"LeaveCriticalSection ( <var>WL</var> )","number":"1.4","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_17","_ref_28","_ref_43","_ref_62","_ref_65","_ref_72","_ref_84","_ref_89"],"key":"LeaveCriticalSection ( WL )"},{"type":"op","aoid":"TriggerTimeout","refId":"sec-triggertimeout","location":"","referencingIds":[],"key":"TriggerTimeout"},{"type":"clause","id":"sec-triggertimeout","aoid":"TriggerTimeout","title":"TriggerTimeout( WL, waiterRecord )","titleHTML":"TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )","number":"1.5","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_34"],"key":"TriggerTimeout( WL, waiterRecord )"},{"type":"op","aoid":"AddWaiter","refId":"sec-addwaiter","location":"","referencingIds":[],"key":"AddWaiter"},{"type":"clause","id":"sec-addwaiter","aoid":"AddWaiter","title":"AddWaiter ( WL, WwaiterRecord )","titleHTML":"AddWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.6","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_70","_ref_86"],"key":"AddWaiter ( WL, WwaiterRecord )"},{"type":"op","aoid":"RemoveWaiter","refId":"sec-removewaiter","location":"","referencingIds":[],"key":"RemoveWaiter"},{"type":"clause","id":"sec-removewaiter","aoid":"RemoveWaiter","title":"RemoveWaiter ( WL, WwaiterRecord )","titleHTML":"RemoveWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.7","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_26","_ref_88"],"key":"RemoveWaiter ( WL, WwaiterRecord )"},{"type":"op","aoid":"Suspend","refId":"sec-suspend","location":"","referencingIds":[],"key":"Suspend"},{"type":"clause","id":"sec-suspend","aoid":"Suspend","title":"Suspend ( WL, W, timeout )","titleHTML":"Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )","number":"1.8","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_71","_ref_87"],"key":"Suspend ( WL, W, timeout )"},{"type":"op","aoid":"NotifyWaiter","refId":"sec-notifywaiter","location":"","referencingIds":[],"key":"NotifyWaiter"},{"type":"clause","id":"sec-notifywaiter","aoid":"NotifyWaiter","title":"NotifyWaiter ( WL, WwaiterRecord )","titleHTML":"NotifyWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.9","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_27","_ref_45","_ref_47"],"key":"NotifyWaiter ( WL, WwaiterRecord )"},{"type":"op","aoid":"DoWait","refId":"sec-dowait","location":"","referencingIds":[],"key":"DoWait"},{"type":"clause","id":"sec-dowait","aoid":"DoWait","title":"DoWait ( mode, typedArray, index, value, timeout )","titleHTML":"DoWait ( <var>mode</var>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.10","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_90","_ref_91"],"key":"DoWait ( mode, typedArray, index, value, timeout )"},{"type":"clause","id":"sec-atomics.wait","aoid":null,"title":"Atomics.wait ( typedArray, index, value, timeout )","titleHTML":"Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.11","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.wait ( typedArray, index, value, timeout )"},{"type":"clause","id":"atomics.waitasync","aoid":null,"title":"Atomics.waitAsync ( typedArray, index, value, timeout )","titleHTML":"Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.12","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync ( typedArray, index, value, timeout )"},{"type":"clause","id":"sec-semantics","aoid":null,"title":"Semantics","titleHTML":"Semantics","number":"1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Semantics"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Atomics.waitAsync">Atomics.waitAsync</a></li><li><span class="item-toggle">◢</span><a href="#sec-semantics" title="Semantics"><span class="secnum">1</span> Semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-hostresolveinagent" title="HostResolveInAgent ( agentSignifier, promiseCapability, resolution)"><span class="secnum">1.1</span> HostResolveInAgent ( <var>agentSignifier</var>, <var>promiseCapability</var>, <var>resolution</var>)</a></li><li><span class="item-toggle-none"></span><a href="#sec-getwaiterlist" title="GetWaiterList ( block, i )"><span class="secnum">1.2</span> GetWaiterList ( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-entercriticalsection" title="EnterCriticalSection ( WL )"><span class="secnum">1.3</span> EnterCriticalSection ( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-leavecriticalsection" title="LeaveCriticalSection ( WL )"><span class="secnum">1.4</span> LeaveCriticalSection ( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-triggertimeout" title="TriggerTimeout( WL, waiterRecord )"><span class="secnum">1.5</span> TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-addwaiter" title="AddWaiter ( WL, WwaiterRecord )"><span class="secnum">1.6</span> AddWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-removewaiter" title="RemoveWaiter ( WL, WwaiterRecord )"><span class="secnum">1.7</span> RemoveWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-suspend" title="Suspend ( WL, W, timeout )"><span class="secnum">1.8</span> Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-notifywaiter" title="NotifyWaiter ( WL, WwaiterRecord )"><span class="secnum">1.9</span> NotifyWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-dowait" title="DoWait ( mode, typedArray, index, value, timeout )"><span class="secnum">1.10</span> DoWait ( <var>mode</var>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.wait" title="Atomics.wait ( typedArray, index, value, timeout )"><span class="secnum">1.11</span> Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#atomics.waitasync" title="Atomics.waitAsync ( typedArray, index, value, timeout )"><span class="secnum">1.12</span> Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li></ol></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 3 Draft / December 2, 2020</h1>
<emu-intro id="intro">
  <h1>Atomics.waitAsync</h1>
  <p>We provide a new API, <code>Atomics.waitAsync</code>, that an <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> can use to wait on a shared memory location (to later be awoken by some <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> calling Atomics.notify on that location) without waiting synchronously (ie, without blocking). Notably this API is useful in agents whose [[CanBlock]] attribute is false, such as the main thread of a web browser document, but the API is not restricted to such agents.</p>
  <p>The API is promise-based. Very high performance is not a requirement, but good performance is desirable.</p>
</emu-intro>

<emu-clause id="sec-semantics">
  <h1><span class="secnum">1</span> Semantics</h1>

  <ins class="block">
  <emu-clause id="sec-hostresolveinagent" aoid="HostResolveInAgent">
    <h1><span class="secnum">1.1</span> HostResolveInAgent ( <var>agentSignifier</var>, <var>promiseCapability</var>, <var>resolution</var>)</h1>
    <p>HostResolveInAgent is an implementation-defined abstract operation that takes three arguments, an <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier <var>agentSignifier</var>, a PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>promiseCapability</var>, and a value <var>resolution</var>. The host's responsibility is to resolve <var>promiseCapability</var> in the <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signified by <var>agentSignifier</var> with <var>resolution</var> in finite time. The host may delay resolving <var>promiseCapability</var> in <var>agentSignifier</var>, e.g. for resource management reasons, but the promise must eventually be resolved.</p>
  </emu-clause>
  </ins>

  <emu-clause id="sec-getwaiterlist">
    <h1><span class="secnum">1.2</span> GetWaiterList ( <var>block</var>, <var>i</var> )</h1>
    <ins class="block">
    <p>A <dfn id="waiter-record">Waiter Record</dfn> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> value used to denote a particular call to <code>Atomics.wait</code> or <code>Atomics.waitAsync</code>. It has fields as defined by <emu-xref href="#table-waiterrecord" id="_ref_0"><a href="#table-waiterrecord">Table 1</a></emu-xref>.</p>
    <emu-table id="table-waiterrecord" caption="Waiter Record Fields"><figure><figcaption>Table 1: <emu-xref href="#waiter-record" id="_ref_3"><a href="#waiter-record">Waiter Record</a></emu-xref> Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[AgentSignifier]]
            </td>
            <td>
              An <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier
            </td>
            <td>
              The <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> that called <code>Atomics.wait</code> or <code>Atomics.waitAsync</code>.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            </td>
            <td>
              A PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> or <emu-val>undefined</emu-val>
            </td>
            <td>
              If denoting a call to <code>Atomics.waitAsync</code>, the resulting promise, otherwise <emu-val>undefined</emu-val>.
            </td>
          </tr>
          <tr>
            <td>
              [[Timeout]]
            </td>
            <td>
              A non-negative Number
            </td>
            <td>
              The timeout in milliseconds.
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            </td>
            <td>
              <emu-val>"ok"</emu-val> or <emu-val>"timed-out"</emu-val>
            </td>
            <td>
              The return value of the call.
            </td>
          </tr>
        </tbody>
      </table>
    </figure></emu-table>
    </ins>
    <del class="block"><p>A <dfn>WaiterList</dfn> is a semantic object that contains an ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>. A WaiterList object also optionally contains a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref> denoting the previous leaving of its critical section.</p></del>
    <ins class="block">
    <p>A <dfn id="waiterlist-record">WaiterList Record</dfn> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> value used to explain waiting and notification of agents via <code>Atomics.wait</code>, <code>Atomics.waitAsync</code>, and <code>Atomics.notify</code>. It has fields as defined by <emu-xref href="#table-waiterlist" id="_ref_1"><a href="#table-waiterlist">Table 2</a></emu-xref>.</p>
    <emu-table id="table-waiterlist" caption="WaiterList Record Fields"><figure><figcaption>Table 2: <emu-xref href="#waiterlist-record" id="_ref_4"><a href="#waiterlist-record">WaiterList Record</a></emu-xref> Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[Waiters]]
            </td>
            <td>
              An ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <emu-xref href="#waiter-record" id="_ref_2"><a href="#waiter-record">Waiter Records</a></emu-xref>
            </td>
            <td>
              The calls to <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> that are waiting on the location with which this <emu-xref href="#sec-getwaiterlist" id="_ref_5"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> is associated.
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            </td>
            <td>
              A <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref> or <emu-val>undefined</emu-val>
            </td>
            <td>
              The event of the most recent leaving of its <emu-xref href="#sec-getwaiterlist" id="_ref_6"><a href="#sec-getwaiterlist">critical section</a></emu-xref>, or <emu-val>undefined</emu-val> if its <emu-xref href="#sec-getwaiterlist" id="_ref_7"><a href="#sec-getwaiterlist">critical section</a></emu-xref> has never been entered.
            </td>
          </tr>
        </tbody>
      </table>
    </figure></emu-table>
    <p>There can be multiple Waiter Records in a WaiterList with the same <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier.</p>
    </ins>
    <p>The <emu-xref href="#sec-agent-clusters"><a href="https://tc39.es/ecma262/#sec-agent-clusters">agent cluster</a></emu-xref> has a store of WaiterList <del>objects</del><ins>Records</ins>; the store is indexed by (<var>block</var>, <var>i</var>)<ins>, where <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var></ins>. WaiterLists are <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref>-independent: a lookup in the store of WaiterLists by (<var>block</var>, <var>i</var>) will result in the same WaiterList object in any <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> in the <emu-xref href="#sec-agent-clusters"><a href="https://tc39.es/ecma262/#sec-agent-clusters">agent cluster</a></emu-xref>.</p>
    <p>Operations on a WaiterList—adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, setting and retrieving the <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref>—may only be performed by agents that have entered the WaiterList's critical section.</p>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>Conceptually, agents that call either <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> are appended to WaiterList. For calls to <code>Atomics.waitAsync</code>, the appended <emu-xref href="#waiter-record" id="_ref_8"><a href="#waiter-record">Waiter Record</a></emu-xref>'s [[PromiseCapability]] field contains the Promise returned by the call. For calls to <code>Atomics.wait</code>, the appended <emu-xref href="#waiter-record" id="_ref_9"><a href="#waiter-record">Waiter Record</a></emu-xref>'s [[PromiseCapability]] field is <emu-val>null</emu-val>.</p>
      <p>Waiting agents are notified in FIFO order for fairness. There is a single FIFO queue shared by both synchronous and asynchronous waiters.</p>
    </div></emu-note>
    <p>The abstract operation GetWaiterList takes two arguments, a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> <var>block</var> and a nonnegative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>i</var> and <var>i</var> + 3 are valid byte offsets within the memory of <var>block</var>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>i</var> is divisible by 4.</li><li>Return the <emu-xref href="#sec-getwaiterlist" id="_ref_10"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> that is referenced by the pair (<var>block</var>, <var>i</var>).</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-entercriticalsection" aoid="EnterCriticalSection">
    <h1><span class="secnum">1.3</span> EnterCriticalSection ( <var>WL</var> )</h1>
    <p>The abstract operation EnterCriticalSection takes one argument, a <emu-xref href="#sec-getwaiterlist" id="_ref_11"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: The calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is not in the <emu-xref href="#sec-getwaiterlist" id="_ref_12"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for any <emu-xref href="#sec-getwaiterlist" id="_ref_13"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref>.</li><li>Wait until no <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is in the <emu-xref href="#sec-getwaiterlist" id="_ref_14"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>, then enter the <emu-xref href="#sec-getwaiterlist" id="_ref_15"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var> (without allowing any other <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> to enter).</li><li>If <var>WL</var><del> has a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref></del><ins>.[[MostRecentLeaveEvent]] is <emu-val>undefined</emu-val></ins>, then<ol><li>NOTE: A <var>WL</var> whose <emu-xref href="#sec-getwaiterlist" id="_ref_16"><a href="#sec-getwaiterlist">critical section</a></emu-xref> has been entered at least once has a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref> set by <emu-xref aoid="LeaveCriticalSection" id="_ref_17"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>eventsRecord</var> be the <emu-xref href="#sec-agent-event-records"><a href="https://tc39.es/ecma262/#sec-agent-event-records">Agent Events Record</a></emu-xref> in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier" id="_ref_18"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li>Let <var>entererEventList</var> be <var>eventsRecord</var>.[[EventList]].</li><li>Let <var>enterEvent</var> be a new <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref>.</li><li>Append <var>enterEvent</var> to <var>entererEventList</var>.</li><li>Let <var>leaveEvent</var> be the <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref> in <var>WL</var>.</li><li>Append (<var>leaveEvent</var>, <var>enterEvent</var>) to <var>eventRecords</var>.[[AgentSynchronizesWith]].</li></ol></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-leavecriticalsection" aoid="LeaveCriticalSection">
    <h1><span class="secnum">1.4</span> LeaveCriticalSection ( <var>WL</var> )</h1>
    <p>The abstract operation LeaveCriticalSection takes one argument, a <emu-xref href="#sec-getwaiterlist" id="_ref_19"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: The calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is in the <emu-xref href="#sec-getwaiterlist" id="_ref_20"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the calling surrounding's <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>eventsRecord</var> be the <emu-xref href="#sec-agent-event-records"><a href="https://tc39.es/ecma262/#sec-agent-event-records">Agent Events Record</a></emu-xref> in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier" id="_ref_21"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li>Let <var>leaverEventList</var> be <var>eventsRecord</var>.[[EventList]].</li><li>Let <var>leaveEvent</var> be a new <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref>.</li><li>Append <var>leaveEvent</var> to <var>leaverEventList</var>.</li><li>Set <del>the <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">Synchronize event</a></emu-xref> in <var>WL</var> to <var>leaveEvent</var></del><ins><var>WL</var>.[[MostRecentLeaveEvent]] to <var>leaveEvent</var></ins>.</li><li>Leave the <emu-xref href="#sec-getwaiterlist" id="_ref_22"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-triggertimeout" aoid="TriggerTimeout">
    <h1><span class="secnum">1.5</span> TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )</h1>
    <p>The abstract operation TriggerTimeout takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_23"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and a <emu-xref href="#waiter-record" id="_ref_24"><a href="#waiter-record">Waiter Record</a></emu-xref> <var>waiterRecord</var>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>waiterRecord</var>.[[Timeout]] is finite.</li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_25"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>waiterRecord</var> is in <var>WL</var>.[[Waiters]], then<ol><li>Set <var>waiterRecord</var>.[[Result]] to <emu-val>"timed-out"</emu-val>.</li><li>Perform <emu-xref aoid="RemoveWaiter" id="_ref_26"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_27"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li></ol></li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_28"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li></ol></emu-alg>
  </emu-clause>
  </ins>

  <emu-clause id="sec-addwaiter" aoid="AddWaiter">
    <h1><span class="secnum">1.6</span> AddWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation AddWaiter takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_29"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and <del>an <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier <var>W</var></del><ins>a <emu-xref href="#waiter-record" id="_ref_30"><a href="#waiter-record">Waiter Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: The calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is in the <emu-xref href="#sec-getwaiterlist" id="_ref_31"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>.</li><li><del><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>W</var> is not on the list of waiters in any <emu-xref href="#sec-getwaiterlist" id="_ref_32"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref>.</del></li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: There is no <emu-xref href="#waiter-record" id="_ref_33"><a href="#waiter-record">Waiter Record</a></emu-xref> in <var>WL</var>.[[Waiters]] whose [[PromiseCapability]] field is <var>waiterRecord</var>.[[PromiseCapability]] and [[AgentSignifier]] field is <var>waiterRecord</var>.[[AgentSignifier]].</ins></li><li><del>Add <var>W</var> to the end of the list of waiters in <var>WL</var>.</del></li><li><ins>Append <var>waiterRecord</var> as the last element of <var>WL</var>.[[Waiters]]</ins></li><li><ins>If <var>waiterRecord</var>.[[Timeout]] is finite, then in parallel,</ins><ol><li><ins>Wait <var>waiterRecord</var>.[[Timeout]] milliseconds.</ins></li><li><ins>Perform <emu-xref aoid="TriggerTimeout" id="_ref_34"><a href="#sec-triggertimeout">TriggerTimeout</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</ins></li></ol></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-removewaiter" aoid="RemoveWaiter">
    <h1><span class="secnum">1.7</span> RemoveWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation RemoveWaiter takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_35"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and <del>an <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier <var>W</var></del><ins>a <emu-xref href="#waiter-record" id="_ref_36"><a href="#waiter-record">Waiter Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: The calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is in the <emu-xref href="#sec-getwaiterlist" id="_ref_37"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <del><var>W</var></del><ins><var>waiterRecord</var></ins> is <del>on the list of waiters</del> in <var>WL</var><ins>.[[Waiters]]</ins>.</li><li>Remove <del><var>W</var></del><ins><var>waiterRecord</var></ins> from <del>the list of waiters in</del> <var>WL</var><ins>.[[Waiters]]</ins>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-suspend" aoid="Suspend">
    <p>Change this function not to take a <var>timeout</var> argument. Timeouts are now handled in the caller. (Not intended as a normative change.)</p>
    <h1><span class="secnum">1.8</span> Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</h1>
    <p>The abstract operation Suspend takes <del>three</del><ins>two</ins> arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_38"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var><del>,</del><ins>and</ins> an <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier <var>W</var><del>, and a nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var></del>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: The calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is in the <emu-xref href="#sec-getwaiterlist" id="_ref_39"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>W</var> is equal to <emu-xref aoid="AgentSignifier" id="_ref_40"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <del><var>W</var> is on the list of waiters.</del><ins>There is a <emu-xref href="#waiter-record" id="_ref_41"><a href="#waiter-record">Waiter Record</a></emu-xref></ins> in <var>WL</var><ins>.[[Waiters]] whose [[AgentSignifier]] field is <var>W</var> and whose [[PromiseCapability]] field is <emu-val>undefined</emu-val>.</ins></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="AgentCanSuspend" id="_ref_42"><a href="https://tc39.es/ecma262/#sec-agentcansuspend">AgentCanSuspend</a></emu-xref>() is <emu-val>true</emu-val>.</li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_43"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>) and suspend <var>W</var><del> for up to <var>timeout</var> milliseconds</del>, performing the combined operation in such a way that a notification that arrives after the <emu-xref href="#sec-getwaiterlist" id="_ref_44"><a href="#sec-getwaiterlist">critical section</a></emu-xref> is exited but before the suspension takes effect is not lost.  <var>W</var> can <del>notify either because the timeout expired or because it was</del><ins>be</ins> notified explicitly by another <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> calling <emu-xref aoid="NotifyWaiter" id="_ref_45"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>, ...), and not for any other reasons at all.</li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_46"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li><del>If <var>W</var> was notified explicitly by another <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> calling <emu-xref aoid="NotifyWaiter" id="_ref_47"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), return <emu-val>true</emu-val>.</del></li><li><del>Return <emu-val>false</emu-val>.</del></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
    <h1><span class="secnum">1.9</span> NotifyWaiter ( <var>WL</var>, <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation NotifyWaiter takes two arguments,
      a <emu-xref href="#sec-getwaiterlist" id="_ref_48"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and <del>an <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> signifier <var>W</var></del><ins>a <emu-xref href="#waiter-record" id="_ref_49"><a href="#waiter-record">Waiter Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: The calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is in the <emu-xref href="#sec-getwaiterlist" id="_ref_50"><a href="#sec-getwaiterlist">critical section</a></emu-xref> for <var>WL</var>.</li><li><del><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>W</var> is on the list of waiters in <var>WL</var>.</del></li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>waiterRecord</var>.[[Result]] is either the String <emu-val>"ok"</emu-val> or the String <emu-val>"timed-out"</emu-val>.</ins></li><li><del>Notify the <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> <var>W</var>.</del></li><li><ins>If <var>waiterRecord</var>.[[PromiseCapability]] is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>NOTE: An <emu-val>undefined</emu-val> promise capability denotes a blocking wait.</ins></li><li><ins>Notify the <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> <var>waiterRecord</var>.[[AgentSignifier]].</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Perform <emu-xref aoid="HostResolveInAgent" id="_ref_51"><a href="#sec-hostresolveinagent">HostResolveInAgent</a></emu-xref>(<var>waiterRecord</var>.[[AgentSignifier]], <var>waiterRecord</var>.[[PromiseCapability]], <var>waiterRecord</var>.[[Result]])</ins></li><li><ins>NOTE: An <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> must not access another <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref>'s promise capability in any capacity beyond passing it to the host.</ins></li></ol></li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>The embedding may delay notifying <del><var>W</var></del><ins>the <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> whose signifier is <var>waiterRecord</var>.[[AgentSignifier]]</ins>, e.g. for resource management reasons, but <del><var>W</var></del><ins>that <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref></ins> must eventually be notified in order to guarantee forward progress.</p>
    </div></emu-note>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-dowait" aoid="DoWait">
    <h1><span class="secnum">1.10</span> DoWait ( <var>mode</var>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p>The abstract operation DoWait takes five arguments, <var>mode</var> which is one of (<emu-const>sync</emu-const>, <emu-const>async</emu-const>), and values <var>typedArray</var>, <var>idnex</var>, <var>value</var>, and <var>timeout</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;<emu-xref aoid="ValidateSharedIntegerTypedArray" id="_ref_52"><a href="https://tc39.es/ecma262/#sec-validatesharedintegertypedarray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;<emu-xref aoid="ValidateAtomicAccess" id="_ref_53"><a href="https://tc39.es/ecma262/#sec-validateatomicaccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>If <var>arrayTypeName</var> is <emu-val>"BigInt64Array"</emu-val>, let <var>v</var> be ?&nbsp;<emu-xref aoid="ToBigInt64" id="_ref_54"><a href="https://tc39.es/ecma262/#sec-tobigint64">ToBigInt64</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_55"><a href="https://tc39.es/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_56"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>q</var>, 0).</li><li>If <var>mode</var> is <emu-const>sync</emu-const>, then<ol><li>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend" id="_ref_57"><a href="https://tc39.es/ecma262/#sec-agentcansuspend">AgentCanSuspend</a></emu-xref>().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList" id="_ref_58"><a href="https://tc39.es/ecma262/#sec-getwaiterlist">GetWaiterList</a></emu-xref>(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>promiseCapability</var> be <emu-val>undefined</emu-val>.</li><li>Let <var>resultObject</var> be <emu-val>undefined</emu-val>.</li><li>If <var>mode</var> is <emu-const>async</emu-const>, then<ol><li>Set <var>promiseCapability</var> to !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_59"><a href="https://tc39.es/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.es/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</li><li>Set <var>resultObject</var> to !&nbsp;OrdinaryObjectCreate(%Object.prototype%).</li></ol></li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_60"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;<emu-xref aoid="AtomicLoad" id="_ref_61"><a href="https://tc39.es/ecma262/#sec-atomicload">AtomicLoad</a></emu-xref>(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_62"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>mode</var> is <emu-const>sync</emu-const>, then<ol><li>Return the String <emu-val>"not-equal"</emu-val>.</li></ol></li><li>Perform !&nbsp;<emu-xref aoid="CreateDataPropertyOrThrow" id="_ref_63"><a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a></emu-xref>(<var>resultObject</var>, <emu-val>"async"</emu-val>, <emu-val>false</emu-val>).</li><li>Perform !&nbsp;<emu-xref aoid="CreateDataPropertyOrThrow" id="_ref_64"><a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a></emu-xref>(<var>resultObject</var>, <emu-val>"value"</emu-val>, <emu-val>"not-equal"</emu-val>).</li><li>Return <var>resultObject</var>.</li></ol></li><li>If <var>t</var> is 0 and <var>mode</var> is <emu-const>async</emu-const>, then<ol><li>NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid Promise machinery.</li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_65"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Perform !&nbsp;<emu-xref aoid="CreateDataPropertyOrThrow" id="_ref_66"><a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a></emu-xref>(<var>resultObject</var>, <emu-val>"async"</emu-val>, <emu-val>false</emu-val>).</li><li>Perform !&nbsp;<emu-xref aoid="CreateDataPropertyOrThrow" id="_ref_67"><a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a></emu-xref>(<var>resultObject</var>, <emu-val>"value"</emu-val>, <emu-val>"timed-out"</emu-val>).</li><li>Return <var>resultObject</var>.</li></ol></li><li>Let <var>W</var> be <emu-xref aoid="AgentSignifier" id="_ref_68"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li>Let <var>waiterRecord</var> be a new <emu-xref href="#waiter-record" id="_ref_69"><a href="#waiter-record">Waiter Record</a></emu-xref> { [[AgentSignifier]]: <var>W</var>, [[PromiseCapability]]: <var>promiseCapability</var>, [[Timeout]]: <var>t</var>, [[Result]]: <emu-val>"ok"</emu-val> }.</li><li>Perform <emu-xref aoid="AddWaiter" id="_ref_70"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li><li>If <var>mode</var> is <emu-const>sync</emu-const>, then<ol><li>Perform <emu-xref aoid="Suspend" id="_ref_71"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>).</li></ol></li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_72"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>mode</var> is <emu-const>sync</emu-const>, then<ol><li>Return <var>waiterRecord</var>.[[Result]].</li></ol></li><li>Perform !&nbsp;<emu-xref aoid="CreateDataPropertyOrThrow" id="_ref_73"><a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a></emu-xref>(<var>resultObject</var>, <emu-val>"async"</emu-val>, <emu-val>true</emu-val>).</li><li>Perform !&nbsp;<emu-xref aoid="CreateDataPropertyOrThrow" id="_ref_74"><a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a></emu-xref>(<var>resultObject</var>, <emu-val>"value"</emu-val>, <var>promiseCapability</var>.[[Promise]]).</li><li>Return <var>resultObject</var>.</li></ol></emu-alg>
  </emu-clause>
  </ins>

  <emu-clause id="sec-atomics.wait">
    <h1><span class="secnum">1.11</span> Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><code>Atomics.wait</code> puts the calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li><del>Let <var>buffer</var> be ?&nbsp;<emu-xref aoid="ValidateSharedIntegerTypedArray" id="_ref_75"><a href="https://tc39.es/ecma262/#sec-validatesharedintegertypedarray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>).</del></li><li><del>Let <var>i</var> be ?&nbsp;<emu-xref aoid="ValidateAtomicAccess" id="_ref_76"><a href="https://tc39.es/ecma262/#sec-validateatomicaccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</del></li><li><del>If <var>arrayTypeName</var> is <emu-val>"BigInt64Array"</emu-val>, let <var>v</var> be ?&nbsp;<emu-xref aoid="ToBigInt64" id="_ref_77"><a href="https://tc39.es/ecma262/#sec-tobigint64">ToBigInt64</a></emu-xref>(<var>value</var>).</del></li><li><del>Otherwise, let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_78"><a href="https://tc39.es/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</del></li><li><del>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_79"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</del></li><li><del>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>q</var>, 0).</del></li><li><del>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend" id="_ref_80"><a href="https://tc39.es/ecma262/#sec-agentcansuspend">AgentCanSuspend</a></emu-xref>().</del></li><li><del>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><del>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</del></li><li><del>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</del></li><li><del>Let <var>indexedPosition</var> be (<var>i</var> × 4) + _offset.</del></li><li><del>Let <var>WL</var> be <emu-xref aoid="GetWaiterList" id="_ref_81"><a href="https://tc39.es/ecma262/#sec-getwaiterlist">GetWaiterList</a></emu-xref>(<var>block</var>, <var>indexedPosition</var>).</del></li><li><del>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_82"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</del></li><li><del>Let <var>w</var> be !&nbsp;<emu-xref aoid="AtomicLoad" id="_ref_83"><a href="https://tc39.es/ecma262/#sec-atomicload">AtomicLoad</a></emu-xref>(<var>typedArray</var>, <var>i</var>).</del></li><li><del>If <var>v</var> is not equal to <var>w</var>, then</del><ol><li><del>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_84"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</del></li><li><del>Return the String <emu-val>"not-equal"</emu-val>.</del></li></ol></li><li><del>Let <var>W</var> be <emu-xref aoid="AgentSignifier" id="_ref_85"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</del></li><li><del>Perform <emu-xref aoid="AddWaiter" id="_ref_86"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li><li><del>Let <var>notified</var> be <emu-xref aoid="Suspend" id="_ref_87"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</del></li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, then</del><ol><li><del><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>W</var> is not on the list of waiters in <var>WL</var>.</del></li></ol></li><li><del>Else,</del><ol><li><del>Perform <emu-xref aoid="RemoveWaiter" id="_ref_88"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li></ol></li><li><del>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_89"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</del></li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, return the String <emu-val>"ok"</emu-val>.</del></li><li><del>Return the String <emu-val>"timed-out"</emu-val>.</del></li><li><ins>Return <emu-xref aoid="DoWait" id="_ref_90"><a href="#sec-dowait">DoWait</a></emu-xref>(<emu-const>sync</emu-const>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var>).</ins></li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="atomics.waitasync">
    <h1><span class="secnum">1.12</span> Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><code>Atomics.waitAsync</code> returns a Promise that is resolved when the calling <emu-xref href="#agent"><a href="https://tc39.es/ecma262/#agent">agent</a></emu-xref> is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Return <emu-xref aoid="DoWait" id="_ref_91"><a href="#sec-dowait">DoWait</a></emu-xref>(<emu-const>async</emu-const>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var>).</li></ol></emu-alg>
  </emu-clause>
  </ins>
</emu-clause>
</div></body>